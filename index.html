<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>3D Shape Trainer</title>
  <style>
    body {
      margin: 0;
      background: #0f172a;
      color: white;
      font-family: Arial, sans-serif;
      display: flex;
      height: 100vh;
    }

    #sidebar {
      width: 300px;
      background: #1e293b;
      padding: 20px;
      box-sizing: border-box;
    }

    #viewer {
      flex: 1;
    }

    button, select {
      width: 100%;
      padding: 8px;
      margin-top: 8px;
      margin-bottom: 8px;
      background: #334155;
      color: white;
      border: none;
      cursor: pointer;
    }

    button:hover {
      background: #475569;
    }

    #timer {
      font-size: 28px;
      font-weight: bold;
      margin: 10px 0;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>

<div id="sidebar">
  <h2>3D Shape Trainer</h2>

  <div id="shapeName">Shape: Cube</div>
  <div id="timer">00:30</div>

  <select id="duration">
    <option value="15">15s</option>
    <option value="30" selected>30s</option>
    <option value="60">60s</option>
    <option value="120">2 min</option>
  </select>

  <button onclick="startTimer()">Start</button>
  <button onclick="pauseTimer()">Pause</button>
  <button onclick="nextShape()">Next Shape</button>
</div>

<div id="viewer">
  <canvas id="canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>

let scene, camera, renderer;
let currentMesh;
let timerInterval;
let remainingTime = 30;
let isRunning = false;

let mouseDown = false;
let prevX = 0;
let prevY = 0;

const shapes = ["cube", "sphere", "cylinder", "cone", "torus"];

init();
animate();

function init() {
  const canvas = document.getElementById("canvas");

  renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
  renderer.setSize(window.innerWidth - 300, window.innerHeight);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f172a);

  camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 300) / window.innerHeight, 0.1, 100);
  camera.position.set(4, 4, 6);
  camera.lookAt(0,0,0);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 10, 5);
  scene.add(light);

  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);

  const grid = new THREE.GridHelper(20, 20);
  scene.add(grid);

  createShape("cube");

  canvas.addEventListener("mousedown", (e) => {
    mouseDown = true;
    prevX = e.clientX;
    prevY = e.clientY;
  });

  canvas.addEventListener("mouseup", () => {
    mouseDown = false;
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!mouseDown || !currentMesh) return;

    const deltaX = e.clientX - prevX;
    const deltaY = e.clientY - prevY;

    currentMesh.rotation.y += deltaX * 0.01;
    currentMesh.rotation.x += deltaY * 0.01;

    prevX = e.clientX;
    prevY = e.clientY;
  });

  window.addEventListener("resize", onResize);
}

function createShape(type) {
  if (currentMesh) scene.remove(currentMesh);

  let geometry;

  switch(type) {
    case "cube":
      geometry = new THREE.BoxGeometry(2,2,2);
      break;
    case "sphere":
      geometry = new THREE.SphereGeometry(1.5,32,32);
      break;
    case "cylinder":
      geometry = new THREE.CylinderGeometry(1,1,3,32);
      break;
    case "cone":
      geometry = new THREE.ConeGeometry(1.5,3,32);
      break;
    case "torus":
      geometry = new THREE.TorusGeometry(1.5,0.5,16,100);
      break;
  }

  const material = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.7,
    metalness: 0.1
  });

  currentMesh = new THREE.Mesh(geometry, material);
  scene.add(currentMesh);

  document.getElementById("shapeName").innerText = "Shape: " + type.toUpperCase();
}

function nextShape() {
  const random = shapes[Math.floor(Math.random() * shapes.length)];
  createShape(random);
}

function startTimer() {
  if (isRunning) return;

  remainingTime = parseInt(document.getElementById("duration").value);
  updateTimerDisplay();

  isRunning = true;

  timerInterval = setInterval(() => {
    remainingTime--;
    updateTimerDisplay();

    if (remainingTime <= 0) {
      clearInterval(timerInterval);
      isRunning = false;
      nextShape();
      startTimer();
    }

  }, 1000);
}

function pauseTimer() {
  clearInterval(timerInterval);
  isRunning = false;
}

function updateTimerDisplay() {
  const minutes = Math.floor(remainingTime / 60);
  const seconds = remainingTime % 60;
  document.getElementById("timer").innerText =
    String(minutes).padStart(2,'0') + ":" +
    String(seconds).padStart(2,'0');
}

function animate() {
  requestAnimationFrame(animate);

  if (currentMesh) {
    currentMesh.rotation.y += 0.005;
  }

  renderer.render(scene, camera);
}

function onResize() {
  renderer.setSize(window.innerWidth - 300, window.innerHeight);
  camera.aspect = (window.innerWidth - 300) / window.innerHeight;
  camera.updateProjectionMatrix();
}

</script>

</body>
</html>